{
  "version": 4,
  "terraform_version": "0.14.11",
  "serial": 18,
  "lineage": "5701af0f-b8d0-060e-9b3b-4ac820ccf1f8",
  "outputs": {},
  "resources": [
    {
      "mode": "managed",
      "type": "aws_ssm_document",
      "name": "this",
      "provider": "provider[\"registry.terraform.io/hashicorp/aws\"]",
      "instances": [
        {
          "index_key": "ssm_doc1",
          "schema_version": 0,
          "attributes": {
            "arn": "arn:aws:ssm:eu-west-1:371337360534:document/disk_full",
            "attachments_source": [],
            "content": "---\r\ndescription: |\r\n  ### Document name - Run-Disk-Stress\r\n  ## What does this document do?\r\n  It runs disk stress on an instance via stress-ng tool.\r\n  ## Input Parameters\r\n  * DurationSeconds: (Required) The duration - in seconds - of the disk stress.\r\n  * Workers: The number of virtual disk stressors (default: 1).\r\n  * Percent: The percentage of virtual disk to use (required).\r\n  * InstallDependencies: If set to True, Systems Manager installs the required dependencies on the target instances. (default: True).\r\n  ## Output Parameters\r\n  None.\r\nschemaVersion: '2.2'\r\nparameters:\r\n  DurationSeconds:\r\n    type: String\r\n    description: \"(Required) The duration - in seconds - of the disk stress.\"\r\n    allowedPattern: \"^[0-9]+$\"\r\n  Workers:\r\n    type: String\r\n    description: \"The number of disk stressors (default: 1).\"\r\n    default: \"1\"\r\n    allowedPattern: \"^[0-9]+$\"\r\n  Percent:\r\n    type: String\r\n    description: \"The percentage of disk to use (required).\"\r\n    allowedPattern: \"^[0-9]+$\"\r\n  InstallDependencies:\r\n    type: String\r\n    description: \"If set to True, Systems Manager installs the required dependencies on the target instances. (default: True).\"\r\n    default: 'True'\r\n    allowedValues:\r\n      - 'True'\r\n      - 'False'\r\nmainSteps:\r\n  - action: aws:runShellScript\r\n    name: InstallDependencies\r\n    precondition:\r\n      StringEquals:\r\n        - platformType\r\n        - Linux\r\n    description: |\r\n      ## Parameter: InstallDependencies\r\n      If set to True, this step installs the required dependecy via operating system's repository. It supports both\r\n      Debian (apt) and CentOS (yum) based package managers.\r\n    inputs:\r\n      runCommand:\r\n        - |\r\n          #!/bin/bash\r\n          if  [[ \"{{ InstallDependencies }}\" == True ]] ; then\r\n            if [[ \"$( which stress-ng 2\u003e/dev/null )\" ]] ; then echo Dependency is already installed. ; exit ; fi\r\n            echo \"Installing required dependencies\"\r\n            if [ -f  \"/etc/system-release\" ] ; then\r\n              if cat /etc/system-release | grep -i 'Amazon Linux' ; then\r\n                sudo amazon-linux-extras install testing\r\n                sudo yum -y install stress-ng\r\n              else\r\n                echo \"There was a problem installing dependencies.\"\r\n                exit 1\r\n              fi\r\n            elif cat /etc/issue | grep -i Ubuntu ; then\r\n              sudo apt-get update -y\r\n              sudo DEBIAN_FRONTEND=noninteractive sudo apt-get install -y stress-ng\r\n            else\r\n              echo \"There was a problem installing dependencies.\"\r\n              exit 1\r\n            fi\r\n          fi\r\n  - action: aws:runShellScript\r\n    name: ExecuteStressNg\r\n    precondition:\r\n      StringEquals:\r\n        - platformType\r\n        - Linux\r\n    description: |\r\n      ## Parameters: DurationSeconds, Workers and Percent\r\n      This step will run a disk stress test on the instance for the specified DurationSeconds time.\r\n      It will start `Workers` number of workers, using `Percent` of the total available disk.\r\n    inputs:\r\n      maxAttempts: 1\r\n      runCommand:\r\n        - |\r\n          if [ {{ DurationSeconds }} -lt 1 ] || [ {{ DurationSeconds }} -gt 43200 ] ; then echo DurationSeconds parameter value must be between 1 and 43200 \u0026\u0026 exit; fi\r\n          pgrep stress-ng \u0026\u0026 echo Another stress-ng command is running, exiting... \u0026\u0026 exit\r\n          echo Initiating disk stress for {{ DurationSeconds }} seconds, {{ Workers }} workers, using {{ Percent }} percent of total available disk...\r\n          stress-ng --fallocate {{ Workers }} --fallocate-bytes {{ Percent }}% -t {{ DurationSeconds }}s --metrics\r\n          echo Finished disk stress.",
            "created_date": "2022-11-15T11:10:25Z",
            "default_version": "1",
            "description": "### Document name - Run-Disk-Stress\n## What does this document do?\nIt runs disk stress on an instance via stress-ng tool.\n## Input Parameters\n* DurationSeconds: (Required) The duration - in seconds - of the disk stress.\n* Workers: The number of virtual disk stressors (default: 1).\n* Percent: The percentage of virtual disk to use (required).\n* InstallDependencies: If set to True, Systems Manager installs the required dependencies on the target instances. (default: True).\n## Output Parameters\nNone.\n",
            "document_format": "YAML",
            "document_type": "Command",
            "document_version": "1",
            "hash": "1223b279715dfc994e92be18b35115ad2fecd56b5152ca516cf15a33ac53302a",
            "hash_type": "Sha256",
            "id": "disk_full",
            "latest_version": "1",
            "name": "disk_full",
            "owner": "371337360534",
            "parameter": [
              {
                "default_value": "",
                "description": "(Required) The duration - in seconds - of the disk stress.",
                "name": "DurationSeconds",
                "type": "String"
              },
              {
                "default_value": "1",
                "description": "The number of disk stressors (default: 1).",
                "name": "Workers",
                "type": "String"
              },
              {
                "default_value": "",
                "description": "The percentage of disk to use (required).",
                "name": "Percent",
                "type": "String"
              },
              {
                "default_value": "True",
                "description": "If set to True, Systems Manager installs the required dependencies on the target instances. (default: True).",
                "name": "InstallDependencies",
                "type": "String"
              }
            ],
            "permissions": null,
            "platform_types": [
              "Linux"
            ],
            "schema_version": "2.2",
            "status": "Active",
            "tags": {
              "env": "test"
            },
            "target_type": "",
            "version_name": ""
          },
          "sensitive_attributes": [],
          "private": "bnVsbA=="
        },
        {
          "index_key": "ssm_doc2",
          "schema_version": 0,
          "attributes": {
            "arn": "arn:aws:ssm:eu-west-1:371337360534:document/cwagent_doc",
            "attachments_source": [],
            "content": "---\r\ndescription: |\r\n  ### Document name - Install-CloudWatch-Agent\r\n  ## What does this document do?\r\n  It install and run aws cloudwatch agent.\r\n  ## Input Parameters\r\n  None.\r\n  ## Output Parameters\r\n  None.\r\nschemaVersion: '2.2'\r\nparameters:\r\nmainSteps:\r\n  - action: aws:runShellScript\r\n    name: InstallCloudWatchAgent\r\n    precondition:\r\n      StringEquals:\r\n        - platformType\r\n        - Linux\r\n    description: |\r\n      ## Parameters: None\r\n      This step will install and launch cloudwatch agent.\r\n    inputs:\r\n      maxAttempts: 1\r\n      runCommand:\r\n        - |\r\n          sudo yum -y install amazon-cloudwatch-agent\r\n          sudo /opt/aws/amazon-cloudwatch-agent/bin/amazon-cloudwatch-agent-ctl -a fetch-config -m ec2 -s",
            "created_date": "2022-11-15T11:10:25Z",
            "default_version": "1",
            "description": "### Document name - Install-CloudWatch-Agent\n## What does this document do?\nIt install and run aws cloudwatch agent.\n## Input Parameters\nNone.\n## Output Parameters\nNone.\n",
            "document_format": "YAML",
            "document_type": "Command",
            "document_version": "1",
            "hash": "50af02c233bc92255f510258fd3e63c2220b2a161256cb6d482232a6a5c74d45",
            "hash_type": "Sha256",
            "id": "cwagent_doc",
            "latest_version": "1",
            "name": "cwagent_doc",
            "owner": "371337360534",
            "parameter": [],
            "permissions": null,
            "platform_types": [
              "Linux"
            ],
            "schema_version": "2.2",
            "status": "Active",
            "tags": {
              "env": "test"
            },
            "target_type": "",
            "version_name": ""
          },
          "sensitive_attributes": [],
          "private": "bnVsbA=="
        },
        {
          "index_key": "ssm_doc3",
          "schema_version": 0,
          "attributes": {
            "arn": "arn:aws:ssm:eu-west-1:371337360534:document/envoy_doc",
            "attachments_source": [],
            "content": "---\r\nschemaVersion: '2.2'\r\ndescription: Install Envoy Proxy\r\nparameters:\r\n  region:\r\n    type: String\r\n  mesh:\r\n    type: String\r\n  vnode:\r\n    type: String\r\n  ignoredUID:\r\n    type: String\r\n    default: '1337'\r\n  envoyVersion:\r\n    type: String\r\n    default: 'v1.23.1.0'\r\n  envoyIngressPort:\r\n    type: String\r\n    default: '15000'\r\n  envoyEgressPort:\r\n    type: String\r\n    default: '15001'\r\n  appPort:\r\n    type: String\r\n    default: '80'\r\n  egressIgnoredIPs:\r\n    type: String\r\n    default: '169.254.169.254,169.254.170.2'\r\n  egressIgnoredPorts:\r\n    type: String\r\n    default: '22'\r\nmainSteps:\r\n- action: aws:configureDocker\r\n  name: ConfigureDocker\r\n  precondition:\r\n    StringEquals:\r\n      - platformType\r\n      - Linux\r\n  inputs:\r\n    action: Install\r\n- action: aws:runShellScript\r\n  name: InstallEnvoy\r\n  precondition:\r\n    StringEquals:\r\n      - platformType\r\n      - Linux\r\n  inputs:\r\n    runCommand:\r\n      - |\r\n        #!/bin/bash -ex\r\n        REGION={{region}}\r\n        MESH={{mesh}}\r\n        VNODE={{vnode}}\r\n        USERID={{ignoredUID}}\r\n        ENVOY_VER={{envoyVersion}}\r\n        sudo yum install -y jq\r\n        aws ecr get-login-password --region $REGION | sudo docker login \\\r\n            --username AWS \\\r\n            --password-stdin 840364872350.dkr.ecr.$REGION.amazonaws.com\r\n        sudo docker run -u $USERID --detach --network host \\\r\n            --env APPMESH_RESOURCE_ARN=mesh/$MESH/virtualNode/$VNODE \\\r\n            840364872350.dkr.ecr.$REGION.amazonaws.com/aws-appmesh-envoy:$ENVOY_VER-prod\r\n- action: aws:runShellScript\r\n  name: EnableRouting\r\n  precondition:\r\n    StringEquals:\r\n      - platformType\r\n      - Linux\r\n  inputs:\r\n    runCommand:\r\n      - |\r\n        #!/bin/bash -ex\r\n        #APPMESH_START_ENABLED=\"0\"\r\n        APPMESH_IGNORE_UID={{ignoredUID}}\r\n        APPMESH_APP_PORTS={{appPort}}\r\n        APPMESH_ENVOY_EGRESS_PORT={{envoyEgressPort}}\r\n        APPMESH_ENVOY_INGRESS_PORT={{envoyIngressPort}}\r\n        APPMESH_EGRESS_IGNORED_IP={{egressIgnoredIPs}}\r\n        # Enable routing on the application start.\r\n        [ -z \"$APPMESH_START_ENABLED\" ] \u0026\u0026 APPMESH_START_ENABLED=\"0\"\r\n        # Enable IPv6.\r\n        [ -z \"$APPMESH_ENABLE_IPV6\" ] \u0026\u0026 APPMESH_ENABLE_IPV6=\"0\"\r\n        # Egress traffic from the processess owned by the following UID/GID will be ignored.\r\n        if [ -z \"$APPMESH_IGNORE_UID\" ] \u0026\u0026 [ -z \"$APPMESH_IGNORE_GID\" ]; then\r\n            echo \"Variables APPMESH_IGNORE_UID and/or APPMESH_IGNORE_GID must be set.\"\r\n            echo \"Envoy must run under those IDs to be able to properly route it's egress traffic.\"\r\n            exit 1\r\n        fi\r\n        # Port numbers Application and Envoy are listening on.\r\n        if [ -z \"$APPMESH_ENVOY_EGRESS_PORT\" ]; then\r\n            echo \"APPMESH_ENVOY_EGRESS_PORT must be defined to forward traffic from the application to the proxy.\"\r\n            exit 1\r\n        fi\r\n        # If an app port was specified, then we also need to enforce the proxies ingress port so we know where to forward traffic.\r\n        if [ ! -z \"$APPMESH_APP_PORTS\" ] \u0026\u0026 [ -z \"$APPMESH_ENVOY_INGRESS_PORT\" ]; then\r\n            echo \"APPMESH_ENVOY_INGRESS_PORT must be defined to forward traffic from the APPMESH_APP_PORTS to the proxy.\"\r\n            exit 1\r\n        fi\r\n        # Comma separated list of ports for which egress traffic will be ignored, we always refuse to route SSH traffic.\r\n        if [ -z \"$APPMESH_EGRESS_IGNORED_PORTS\" ]; then\r\n            APPMESH_EGRESS_IGNORED_PORTS=\"22\"\r\n        else\r\n            APPMESH_EGRESS_IGNORED_PORTS=\"$APPMESH_EGRESS_IGNORED_PORTS,22\"\r\n        fi\r\n        function initialize() {\r\n            echo \"=== Initializing ===\"\r\n            if [ ! -z \"$APPMESH_APP_PORTS\" ]; then\r\n                iptables -t nat -N APPMESH_INGRESS\r\n                if [ \"$APPMESH_ENABLE_IPV6\" == \"1\" ]; then\r\n                    ip6tables -t nat -N APPMESH_INGRESS\r\n                fi\r\n            fi\r\n            iptables -t nat -N APPMESH_EGRESS\r\n            if [ \"$APPMESH_ENABLE_IPV6\" == \"1\" ]; then\r\n                ip6tables -t nat -N APPMESH_EGRESS\r\n            fi\r\n        }\r\n        function enable_egress_routing() {\r\n            # Stuff to ignore\r\n            [ ! -z \"$APPMESH_IGNORE_UID\" ] \u0026\u0026 \\\r\n                iptables -t nat -A APPMESH_EGRESS \\\r\n                -m owner --uid-owner $APPMESH_IGNORE_UID \\\r\n                -j RETURN\r\n            [ ! -z \"$APPMESH_IGNORE_GID\" ] \u0026\u0026 \\\r\n                iptables -t nat -A APPMESH_EGRESS \\\r\n                -m owner --gid-owner $APPMESH_IGNORE_GID \\\r\n                -j RETURN\r\n            [ ! -z \"$APPMESH_EGRESS_IGNORED_PORTS\" ] \u0026\u0026 \\\r\n                for IGNORED_PORT in $(echo \"$APPMESH_EGRESS_IGNORED_PORTS\" | tr \",\" \"\\n\"); do\r\n                  iptables -t nat -A APPMESH_EGRESS \\\r\n                  -p tcp \\\r\n                  -m multiport --dports \"$IGNORED_PORT\" \\\r\n                  -j RETURN\r\n                done\r\n            if [ \"$APPMESH_ENABLE_IPV6\" == \"1\" ]; then\r\n              # Stuff to ignore ipv6\r\n              [ ! -z \"$APPMESH_IGNORE_UID\" ] \u0026\u0026 \\\r\n                  ip6tables -t nat -A APPMESH_EGRESS \\\r\n                  -m owner --uid-owner $APPMESH_IGNORE_UID \\\r\n                  -j RETURN\r\n              [ ! -z \"$APPMESH_IGNORE_GID\" ] \u0026\u0026 \\\r\n                  ip6tables -t nat -A APPMESH_EGRESS \\\r\n                  -m owner --gid-owner $APPMESH_IGNORE_GID \\\r\n                  -j RETURN\r\n              [ ! -z \"$APPMESH_EGRESS_IGNORED_PORTS\" ] \u0026\u0026 \\\r\n                for IGNORED_PORT in $(echo \"$APPMESH_EGRESS_IGNORED_PORTS\" | tr \",\" \"\\n\"); do\r\n                  ip6tables -t nat -A APPMESH_EGRESS \\\r\n                  -p tcp \\\r\n                  -m multiport --dports \"$IGNORED_PORT\" \\\r\n                  -j RETURN\r\n                done\r\n            fi\r\n            # The list can contain both IPv4 and IPv6 addresses. We will loop over this list\r\n            # to add every IPv4 address into `iptables` and every IPv6 address into `ip6tables`.\r\n            [ ! -z \"$APPMESH_EGRESS_IGNORED_IP\" ] \u0026\u0026 \\\r\n                for IP_ADDR in $(echo \"$APPMESH_EGRESS_IGNORED_IP\" | tr \",\" \"\\n\"); do\r\n                    if [[ $IP_ADDR =~ .*:.* ]]\r\n                    then\r\n                        [ \"$APPMESH_ENABLE_IPV6\" == \"1\" ] \u0026\u0026 \\\r\n                            ip6tables -t nat -A APPMESH_EGRESS \\\r\n                                -p tcp \\\r\n                                -d \"$IP_ADDR\" \\\r\n                                -j RETURN\r\n                    else\r\n                        iptables -t nat -A APPMESH_EGRESS \\\r\n                            -p tcp \\\r\n                            -d \"$IP_ADDR\" \\\r\n                            -j RETURN\r\n                    fi\r\n                done\r\n            # Redirect everything that is not ignored\r\n            iptables -t nat -A APPMESH_EGRESS \\\r\n                -p tcp \\\r\n                -j REDIRECT --to $APPMESH_ENVOY_EGRESS_PORT\r\n            # Apply APPMESH_EGRESS chain to non local traffic\r\n            iptables -t nat -A OUTPUT \\\r\n                -p tcp \\\r\n                -m addrtype ! --dst-type LOCAL \\\r\n                -j APPMESH_EGRESS\r\n            if [ \"$APPMESH_ENABLE_IPV6\" == \"1\" ]; then\r\n                # Redirect everything that is not ignored ipv6\r\n                ip6tables -t nat -A APPMESH_EGRESS \\\r\n                    -p tcp \\\r\n                    -j REDIRECT --to $APPMESH_ENVOY_EGRESS_PORT\r\n                # Apply APPMESH_EGRESS chain to non local traffic ipv6\r\n                ip6tables -t nat -A OUTPUT \\\r\n                    -p tcp \\\r\n                    -m addrtype ! --dst-type LOCAL \\\r\n                    -j APPMESH_EGRESS\r\n            fi\r\n        }\r\n        function enable_ingress_redirect_routing() {\r\n            # Route everything arriving at the application port to Envoy\r\n            iptables -t nat -A APPMESH_INGRESS \\\r\n                -p tcp \\\r\n                -m multiport --dports \"$APPMESH_APP_PORTS\" \\\r\n                -j REDIRECT --to-port \"$APPMESH_ENVOY_INGRESS_PORT\"\r\n            # Apply AppMesh ingress chain to everything non-local\r\n            iptables -t nat -A PREROUTING \\\r\n                -p tcp \\\r\n                -m addrtype ! --src-type LOCAL \\\r\n                -j APPMESH_INGRESS\r\n            if [ \"$APPMESH_ENABLE_IPV6\" == \"1\" ]; then\r\n                # Route everything arriving at the application port to Envoy ipv6\r\n                ip6tables -t nat -A APPMESH_INGRESS \\\r\n                    -p tcp \\\r\n                    -m multiport --dports \"$APPMESH_APP_PORTS\" \\\r\n                    -j REDIRECT --to-port \"$APPMESH_ENVOY_INGRESS_PORT\"\r\n                # Apply AppMesh ingress chain to everything non-local ipv6\r\n                ip6tables -t nat -A PREROUTING \\\r\n                    -p tcp \\\r\n                    -m addrtype ! --src-type LOCAL \\\r\n                    -j APPMESH_INGRESS\r\n            fi\r\n        }\r\n        function enable_routing() {\r\n            echo \"=== Enabling routing ===\"\r\n            enable_egress_routing\r\n            if [ ! -z \"$APPMESH_APP_PORTS\" ]; then\r\n                enable_ingress_redirect_routing\r\n            fi\r\n        }\r\n        function disable_routing() {\r\n            echo \"=== Disabling routing ===\"\r\n            iptables -t nat -F APPMESH_INGRESS\r\n            iptables -t nat -F APPMESH_EGRESS\r\n            if [ \"$APPMESH_ENABLE_IPV6\" == \"1\" ]; then\r\n                ip6tables -t nat -F APPMESH_INGRESS\r\n                ip6tables -t nat -F APPMESH_EGRESS\r\n            fi\r\n        }\r\n        function dump_status() {\r\n            echo \"=== iptables FORWARD table ===\"\r\n            iptables -L -v -n\r\n            echo \"=== iptables NAT table ===\"\r\n            iptables -t nat -L -v -n\r\n            if [ \"$APPMESH_ENABLE_IPV6\" == \"1\" ]; then\r\n                echo \"=== ip6tables FORWARD table ===\"\r\n                ip6tables -L -v -n\r\n                echo \"=== ip6tables NAT table ===\"\r\n                ip6tables -t nat -L -v -n\r\n            fi\r\n        }\r\n        function clean_up() {\r\n            disable_routing\r\n            ruleNum=$(iptables -L PREROUTING -t nat --line-numbers | grep APPMESH_INGRESS | cut -d \" \" -f 1)\r\n            iptables -t nat -D PREROUTING $ruleNum\r\n            ruleNum=$(iptables -L OUTPUT -t nat --line-numbers | grep APPMESH_EGRESS | cut -d \" \" -f 1)\r\n            iptables -t nat -D OUTPUT $ruleNum\r\n            iptables -t nat -X APPMESH_INGRESS\r\n            iptables -t nat -X APPMESH_EGRESS\r\n            if [ \"$APPMESH_ENABLE_IPV6\" == \"1\" ]; then\r\n                ruleNum=$(ip6tables -L PREROUTING -t nat --line-numbers | grep APPMESH_INGRESS | cut -d \" \" -f 1)\r\n                ip6tables -t nat -D PREROUTING $ruleNum\r\n                ruleNum=$(ip6tables -L OUTPUT -t nat --line-numbers | grep APPMESH_EGRESS | cut -d \" \" -f 1)\r\n                ip6tables -t nat -D OUTPUT $ruleNum\r\n                ip6tables -t nat -X APPMESH_INGRESS\r\n                ip6tables -t nat -X APPMESH_EGRESS\r\n            fi\r\n        }\r\n        function main_loop() {\r\n            echo \"=== Entering main loop ===\"\r\n            while read -p '\u003e ' cmd; do\r\n                case \"$cmd\" in\r\n                    \"quit\")\r\n                        clean_up\r\n                        break\r\n                        ;;\r\n                    \"status\")\r\n                        dump_status\r\n                        ;;\r\n                    \"enable\")\r\n                        enable_routing\r\n                        ;;\r\n                    \"disable\")\r\n                        disable_routing\r\n                        ;;\r\n                    *)\r\n                        echo \"Available commands: quit, status, enable, disable\"\r\n                        ;;\r\n                esac\r\n            done\r\n        }\r\n        function print_config() {\r\n            echo \"=== Input configuration ===\"\r\n            env | grep APPMESH_ || true\r\n        }\r\n        print_config\r\n        initialize\r\n        if [ \"$APPMESH_START_ENABLED\" == \"1\" ]; then\r\n            enable_routing\r\n        fi\r\n        main_loop\r\n",
            "created_date": "2022-11-15T11:10:25Z",
            "default_version": "1",
            "description": "Install Envoy Proxy",
            "document_format": "YAML",
            "document_type": "Command",
            "document_version": "1",
            "hash": "a0703ce1435365ca0813b1f285d76e441b9e6c891ddbb742450e8f1d0deaea9f",
            "hash_type": "Sha256",
            "id": "envoy_doc",
            "latest_version": "1",
            "name": "envoy_doc",
            "owner": "371337360534",
            "parameter": [
              {
                "default_value": "",
                "description": "",
                "name": "region",
                "type": "String"
              },
              {
                "default_value": "",
                "description": "",
                "name": "mesh",
                "type": "String"
              },
              {
                "default_value": "",
                "description": "",
                "name": "vnode",
                "type": "String"
              },
              {
                "default_value": "1337",
                "description": "",
                "name": "ignoredUID",
                "type": "String"
              },
              {
                "default_value": "v1.23.1.0",
                "description": "",
                "name": "envoyVersion",
                "type": "String"
              },
              {
                "default_value": "15000",
                "description": "",
                "name": "envoyIngressPort",
                "type": "String"
              },
              {
                "default_value": "15001",
                "description": "",
                "name": "envoyEgressPort",
                "type": "String"
              },
              {
                "default_value": "80",
                "description": "",
                "name": "appPort",
                "type": "String"
              },
              {
                "default_value": "169.254.169.254,169.254.170.2",
                "description": "",
                "name": "egressIgnoredIPs",
                "type": "String"
              },
              {
                "default_value": "22",
                "description": "",
                "name": "egressIgnoredPorts",
                "type": "String"
              }
            ],
            "permissions": null,
            "platform_types": [
              "Linux"
            ],
            "schema_version": "2.2",
            "status": "Active",
            "tags": {
              "env": "test"
            },
            "target_type": "",
            "version_name": ""
          },
          "sensitive_attributes": [],
          "private": "bnVsbA=="
        }
      ]
    }
  ]
}
